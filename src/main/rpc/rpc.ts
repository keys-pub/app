// Code generated by protoc-gen-tsrpc DO NOT EDIT.
// InputID: 1f7f80d49a60c1764457eea23f2a84d399ea002e
import {client} from './client'

import {
  KeyGenerateRequest,
  KeyGenerateResponse,
  KeysRequest,
  KeysResponse,
  KeyRequest,
  KeyResponse,
  KeyImportRequest,
  KeyImportResponse,
  KeyExportRequest,
  KeyExportResponse,
  KeyRemoveRequest,
  KeyRemoveResponse,
  SignRequest,
  SignResponse,
  SignFileInput,
  SignFileOutput,
  SignInput,
  SignOutput,
  VerifyRequest,
  VerifyResponse,
  VerifyFileInput,
  VerifyFileOutput,
  VerifyInput,
  VerifyOutput,
  EncryptRequest,
  EncryptResponse,
  EncryptInput,
  EncryptOutput,
  EncryptFileInput,
  EncryptFileOutput,
  DecryptRequest,
  DecryptResponse,
  DecryptFileInput,
  DecryptFileOutput,
  DecryptInput,
  DecryptOutput,
  SigchainRequest,
  SigchainResponse,
  StatementRequest,
  StatementResponse,
  StatementCreateRequest,
  StatementCreateResponse,
  StatementRevokeRequest,
  StatementRevokeResponse,
  UserRequest,
  UserResponse,
  UserSearchRequest,
  UserSearchResponse,
  UserServiceRequest,
  UserServiceResponse,
  UserSignRequest,
  UserSignResponse,
  UserAddRequest,
  UserAddResponse,
  ItemRequest,
  ItemResponse,
  ItemsRequest,
  ItemsResponse,
  PullRequest,
  PullResponse,
  PushRequest,
  PushResponse,
  ConfigRequest,
  ConfigResponse,
  ConfigSetRequest,
  ConfigSetResponse,
  AuthSetupRequest,
  AuthSetupResponse,
  AuthUnlockRequest,
  AuthUnlockResponse,
  AuthLockRequest,
  AuthLockResponse,
  RuntimeStatusRequest,
  RuntimeStatusResponse,
  RandRequest,
  RandResponse,
  CollectionsRequest,
  CollectionsResponse,
  DocumentsRequest,
  DocumentsResponse,
  DocumentDeleteRequest,
  DocumentDeleteResponse,
  InboxRequest,
  InboxResponse,
  MessagePrepareRequest,
  MessagePrepareResponse,
  MessageCreateRequest,
  MessageCreateResponse,
  MessagesRequest,
  MessagesResponse,
  WatchRequest,
  WatchEvent,
} from './types'

export type RPCError = {
  code: number
  message: string
  details: string
}

export const keyGenerate = (
  req: KeyGenerateRequest,
  respFn: ((resp: KeyGenerateResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_GENERATE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.keyGenerate(req, (err: RPCError | void, resp: KeyGenerateResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_GENERATE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_KEY_GENERATE_RESPONSE',
      payload: resp,
    })
  })
}

export const keys = (
  req: KeysRequest,
  respFn: ((resp: KeysResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEYS_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.keys(req, (err: RPCError | void, resp: KeysResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEYS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_KEYS_RESPONSE',
      payload: resp,
    })
  })
}

export const key = (
  req: KeyRequest,
  respFn: ((resp: KeyResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.key(req, (err: RPCError | void, resp: KeyResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_KEY_RESPONSE',
      payload: resp,
    })
  })
}

export const keyImport = (
  req: KeyImportRequest,
  respFn: ((resp: KeyImportResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_IMPORT_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.keyImport(req, (err: RPCError | void, resp: KeyImportResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_IMPORT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_KEY_IMPORT_RESPONSE',
      payload: resp,
    })
  })
}

export const keyExport = (
  req: KeyExportRequest,
  respFn: ((resp: KeyExportResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_EXPORT_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.keyExport(req, (err: RPCError | void, resp: KeyExportResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_EXPORT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_KEY_EXPORT_RESPONSE',
      payload: resp,
    })
  })
}

export const keyRemove = (
  req: KeyRemoveRequest,
  respFn: ((resp: KeyRemoveResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_REMOVE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.keyRemove(req, (err: RPCError | void, resp: KeyRemoveResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_REMOVE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_KEY_REMOVE_RESPONSE',
      payload: resp,
    })
  })
}

export const sign = (
  req: SignRequest,
  respFn: ((resp: SignResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGN_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.sign(req, (err: RPCError | void, resp: SignResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGN', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_SIGN_RESPONSE',
      payload: resp,
    })
  })
}

export const signFile = (
  req: SignFileInput,
  respFn: ((resp: SignFileOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGN_FILE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.signFile(req, (err: RPCError | void, resp: SignFileOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGN_FILE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_SIGN_FILE_RESPONSE',
      payload: resp,
    })
  })
}

export const signStream = (
  req: SignInput,
  respFn: ((resp: SignOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGN_STREAM_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.signStream(req, (err: RPCError | void, resp: SignOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGN_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_SIGN_STREAM_RESPONSE',
      payload: resp,
    })
  })
}

export const verify = (
  req: VerifyRequest,
  respFn: ((resp: VerifyResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.verify(req, (err: RPCError | void, resp: VerifyResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_VERIFY_RESPONSE',
      payload: resp,
    })
  })
}

export const verifyFile = (
  req: VerifyFileInput,
  respFn: ((resp: VerifyFileOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_FILE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.verifyFile(req, (err: RPCError | void, resp: VerifyFileOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY_FILE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_VERIFY_FILE_RESPONSE',
      payload: resp,
    })
  })
}

export const verifyStream = (
  req: VerifyInput,
  respFn: ((resp: VerifyOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_STREAM_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.verifyStream(req, (err: RPCError | void, resp: VerifyOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_VERIFY_STREAM_RESPONSE',
      payload: resp,
    })
  })
}

export const verifyArmoredStream = (
  req: VerifyInput,
  respFn: ((resp: VerifyOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_ARMORED_STREAM_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.verifyArmoredStream(req, (err: RPCError | void, resp: VerifyOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY_ARMORED_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_VERIFY_ARMORED_STREAM_RESPONSE',
      payload: resp,
    })
  })
}

export const encrypt = (
  req: EncryptRequest,
  respFn: ((resp: EncryptResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ENCRYPT_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.encrypt(req, (err: RPCError | void, resp: EncryptResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ENCRYPT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_ENCRYPT_RESPONSE',
      payload: resp,
    })
  })
}

export const encryptStream = (
  req: EncryptInput,
  respFn: ((resp: EncryptOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ENCRYPT_STREAM_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.encryptStream(req, (err: RPCError | void, resp: EncryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ENCRYPT_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_ENCRYPT_STREAM_RESPONSE',
      payload: resp,
    })
  })
}

export const encryptFile = (
  req: EncryptFileInput,
  respFn: ((resp: EncryptFileOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ENCRYPT_FILE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.encryptFile(req, (err: RPCError | void, resp: EncryptFileOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ENCRYPT_FILE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_ENCRYPT_FILE_RESPONSE',
      payload: resp,
    })
  })
}

export const decrypt = (
  req: DecryptRequest,
  respFn: ((resp: DecryptResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.decrypt(req, (err: RPCError | void, resp: DecryptResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_DECRYPT_RESPONSE',
      payload: resp,
    })
  })
}

export const decryptFile = (
  req: DecryptFileInput,
  respFn: ((resp: DecryptFileOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_FILE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.decryptFile(req, (err: RPCError | void, resp: DecryptFileOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT_FILE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_DECRYPT_FILE_RESPONSE',
      payload: resp,
    })
  })
}

export const decryptStream = (
  req: DecryptInput,
  respFn: ((resp: DecryptOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_STREAM_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.decryptStream(req, (err: RPCError | void, resp: DecryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_DECRYPT_STREAM_RESPONSE',
      payload: resp,
    })
  })
}

export const decryptArmoredStream = (
  req: DecryptInput,
  respFn: ((resp: DecryptOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_ARMORED_STREAM_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.decryptArmoredStream(req, (err: RPCError | void, resp: DecryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT_ARMORED_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_DECRYPT_ARMORED_STREAM_RESPONSE',
      payload: resp,
    })
  })
}

export const signcryptOpenStream = (
  req: DecryptInput,
  respFn: ((resp: DecryptOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGNCRYPT_OPEN_STREAM_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.signcryptOpenStream(req, (err: RPCError | void, resp: DecryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGNCRYPT_OPEN_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_SIGNCRYPT_OPEN_STREAM_RESPONSE',
      payload: resp,
    })
  })
}

export const signcryptOpenArmoredStream = (
  req: DecryptInput,
  respFn: ((resp: DecryptOutput) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.signcryptOpenArmoredStream(req, (err: RPCError | void, resp: DecryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM_RESPONSE',
      payload: resp,
    })
  })
}

export const sigchain = (
  req: SigchainRequest,
  respFn: ((resp: SigchainResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGCHAIN_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.sigchain(req, (err: RPCError | void, resp: SigchainResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGCHAIN', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_SIGCHAIN_RESPONSE',
      payload: resp,
    })
  })
}

export const statement = (
  req: StatementRequest,
  respFn: ((resp: StatementResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_STATEMENT_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.statement(req, (err: RPCError | void, resp: StatementResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_STATEMENT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_STATEMENT_RESPONSE',
      payload: resp,
    })
  })
}

export const statementCreate = (
  req: StatementCreateRequest,
  respFn: ((resp: StatementCreateResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_STATEMENT_CREATE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.statementCreate(req, (err: RPCError | void, resp: StatementCreateResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_STATEMENT_CREATE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_STATEMENT_CREATE_RESPONSE',
      payload: resp,
    })
  })
}

export const statementRevoke = (
  req: StatementRevokeRequest,
  respFn: ((resp: StatementRevokeResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_STATEMENT_REVOKE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.statementRevoke(req, (err: RPCError | void, resp: StatementRevokeResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_STATEMENT_REVOKE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_STATEMENT_REVOKE_RESPONSE',
      payload: resp,
    })
  })
}

export const user = (
  req: UserRequest,
  respFn: ((resp: UserResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.user(req, (err: RPCError | void, resp: UserResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_USER_RESPONSE',
      payload: resp,
    })
  })
}

export const userSearch = (
  req: UserSearchRequest,
  respFn: ((resp: UserSearchResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_SEARCH_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.userSearch(req, (err: RPCError | void, resp: UserSearchResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_SEARCH', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_USER_SEARCH_RESPONSE',
      payload: resp,
    })
  })
}

export const userService = (
  req: UserServiceRequest,
  respFn: ((resp: UserServiceResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_SERVICE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.userService(req, (err: RPCError | void, resp: UserServiceResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_SERVICE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_USER_SERVICE_RESPONSE',
      payload: resp,
    })
  })
}

export const userSign = (
  req: UserSignRequest,
  respFn: ((resp: UserSignResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_SIGN_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.userSign(req, (err: RPCError | void, resp: UserSignResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_SIGN', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_USER_SIGN_RESPONSE',
      payload: resp,
    })
  })
}

export const userAdd = (
  req: UserAddRequest,
  respFn: ((resp: UserAddResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_ADD_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.userAdd(req, (err: RPCError | void, resp: UserAddResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_ADD', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_USER_ADD_RESPONSE',
      payload: resp,
    })
  })
}

export const item = (
  req: ItemRequest,
  respFn: ((resp: ItemResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ITEM_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.item(req, (err: RPCError | void, resp: ItemResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ITEM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_ITEM_RESPONSE',
      payload: resp,
    })
  })
}

export const items = (
  req: ItemsRequest,
  respFn: ((resp: ItemsResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ITEMS_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.items(req, (err: RPCError | void, resp: ItemsResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ITEMS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_ITEMS_RESPONSE',
      payload: resp,
    })
  })
}

export const pull = (
  req: PullRequest,
  respFn: ((resp: PullResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_PULL_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.pull(req, (err: RPCError | void, resp: PullResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_PULL', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_PULL_RESPONSE',
      payload: resp,
    })
  })
}

export const push = (
  req: PushRequest,
  respFn: ((resp: PushResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_PUSH_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.push(req, (err: RPCError | void, resp: PushResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_PUSH', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_PUSH_RESPONSE',
      payload: resp,
    })
  })
}

export const config = (
  req: ConfigRequest,
  respFn: ((resp: ConfigResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_CONFIG_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.config(req, (err: RPCError | void, resp: ConfigResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_CONFIG', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_CONFIG_RESPONSE',
      payload: resp,
    })
  })
}

export const configSet = (
  req: ConfigSetRequest,
  respFn: ((resp: ConfigSetResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_CONFIG_SET_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.configSet(req, (err: RPCError | void, resp: ConfigSetResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_CONFIG_SET', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_CONFIG_SET_RESPONSE',
      payload: resp,
    })
  })
}

export const authSetup = (
  req: AuthSetupRequest,
  respFn: ((resp: AuthSetupResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_AUTH_SETUP_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.authSetup(req, (err: RPCError | void, resp: AuthSetupResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_AUTH_SETUP', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_AUTH_SETUP_RESPONSE',
      payload: resp,
    })
  })
}

export const authUnlock = (
  req: AuthUnlockRequest,
  respFn: ((resp: AuthUnlockResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_AUTH_UNLOCK_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.authUnlock(req, (err: RPCError | void, resp: AuthUnlockResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_AUTH_UNLOCK', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_AUTH_UNLOCK_RESPONSE',
      payload: resp,
    })
  })
}

export const authLock = (
  req: AuthLockRequest,
  respFn: ((resp: AuthLockResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_AUTH_LOCK_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.authLock(req, (err: RPCError | void, resp: AuthLockResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_AUTH_LOCK', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_AUTH_LOCK_RESPONSE',
      payload: resp,
    })
  })
}

export const runtimeStatus = (
  req: RuntimeStatusRequest,
  respFn: ((resp: RuntimeStatusResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_RUNTIME_STATUS_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.runtimeStatus(req, (err: RPCError | void, resp: RuntimeStatusResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_RUNTIME_STATUS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_RUNTIME_STATUS_RESPONSE',
      payload: resp,
    })
  })
}

export const rand = (
  req: RandRequest,
  respFn: ((resp: RandResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_RAND_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.rand(req, (err: RPCError | void, resp: RandResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_RAND', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_RAND_RESPONSE',
      payload: resp,
    })
  })
}

export const collections = (
  req: CollectionsRequest,
  respFn: ((resp: CollectionsResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_COLLECTIONS_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.collections(req, (err: RPCError | void, resp: CollectionsResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_COLLECTIONS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_COLLECTIONS_RESPONSE',
      payload: resp,
    })
  })
}

export const documents = (
  req: DocumentsRequest,
  respFn: ((resp: DocumentsResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DOCUMENTS_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.documents(req, (err: RPCError | void, resp: DocumentsResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DOCUMENTS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_DOCUMENTS_RESPONSE',
      payload: resp,
    })
  })
}

export const documentDelete = (
  req: DocumentDeleteRequest,
  respFn: ((resp: DocumentDeleteResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DOCUMENT_DELETE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.documentDelete(req, (err: RPCError | void, resp: DocumentDeleteResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DOCUMENT_DELETE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_DOCUMENT_DELETE_RESPONSE',
      payload: resp,
    })
  })
}

export const inbox = (
  req: InboxRequest,
  respFn: ((resp: InboxResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_INBOX_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.inbox(req, (err: RPCError | void, resp: InboxResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_INBOX', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_INBOX_RESPONSE',
      payload: resp,
    })
  })
}

export const messagePrepare = (
  req: MessagePrepareRequest,
  respFn: ((resp: MessagePrepareResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_MESSAGE_PREPARE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.messagePrepare(req, (err: RPCError | void, resp: MessagePrepareResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_MESSAGE_PREPARE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_MESSAGE_PREPARE_RESPONSE',
      payload: resp,
    })
  })
}

export const messageCreate = (
  req: MessageCreateRequest,
  respFn: ((resp: MessageCreateResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_MESSAGE_CREATE_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.messageCreate(req, (err: RPCError | void, resp: MessageCreateResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_MESSAGE_CREATE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_MESSAGE_CREATE_RESPONSE',
      payload: resp,
    })
  })
}

export const messages = (
  req: MessagesRequest,
  respFn: ((resp: MessagesResponse) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_MESSAGES_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.messages(req, (err: RPCError | void, resp: MessagesResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_MESSAGES', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_MESSAGES_RESPONSE',
      payload: resp,
    })
  })
}

export const watch = (
  req: WatchRequest,
  respFn: ((resp: WatchEvent) => void) | void,
  errFn: ErrFn | void
) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_WATCH_REQUEST',
    payload: req,
  })
  let cl = await client()
  cl.watch(req, (err: RPCError | void, resp: WatchEvent | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      }
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_WATCH', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
    dispatch({
      type: 'KEYS_WATCH_RESPONSE',
      payload: resp,
    })
  })
}

export const RPC = {
  keyGenerate,
  keys,
  key,
  keyImport,
  keyExport,
  keyRemove,
  sign,
  signFile,
  signStream,
  verify,
  verifyFile,
  verifyStream,
  verifyArmoredStream,
  encrypt,
  encryptStream,
  encryptFile,
  decrypt,
  decryptFile,
  decryptStream,
  decryptArmoredStream,
  signcryptOpenStream,
  signcryptOpenArmoredStream,
  sigchain,
  statement,
  statementCreate,
  statementRevoke,
  user,
  userSearch,
  userService,
  userSign,
  userAdd,
  item,
  items,
  pull,
  push,
  config,
  configSet,
  authSetup,
  authUnlock,
  authLock,
  runtimeStatus,
  rand,
  collections,
  documents,
  documentDelete,
  inbox,
  messagePrepare,
  messageCreate,
  messages,
  watch,
}

export type RPCState = {
  keyGenerateLoading: boolean
  keyGenerateRequest: KeyGenerateRequest | void
  keyGenerate: KeyGenerateResponse | void
  keysLoading: boolean
  keysRequest: KeysRequest | void
  keys: KeysResponse | void
  keyLoading: boolean
  keyRequest: KeyRequest | void
  key: KeyResponse | void
  keyImportLoading: boolean
  keyImportRequest: KeyImportRequest | void
  keyImport: KeyImportResponse | void
  keyExportLoading: boolean
  keyExportRequest: KeyExportRequest | void
  keyExport: KeyExportResponse | void
  keyRemoveLoading: boolean
  keyRemoveRequest: KeyRemoveRequest | void
  keyRemove: KeyRemoveResponse | void
  signLoading: boolean
  signRequest: SignRequest | void
  sign: SignResponse | void
  signFileLoading: boolean
  signFileRequest: SignFileInput | void
  signFile: SignFileOutput | void
  signStreamLoading: boolean
  signStreamRequest: SignInput | void
  signStream: SignOutput | void
  verifyLoading: boolean
  verifyRequest: VerifyRequest | void
  verify: VerifyResponse | void
  verifyFileLoading: boolean
  verifyFileRequest: VerifyFileInput | void
  verifyFile: VerifyFileOutput | void
  verifyStreamLoading: boolean
  verifyStreamRequest: VerifyInput | void
  verifyStream: VerifyOutput | void
  verifyArmoredStreamLoading: boolean
  verifyArmoredStreamRequest: VerifyInput | void
  verifyArmoredStream: VerifyOutput | void
  encryptLoading: boolean
  encryptRequest: EncryptRequest | void
  encrypt: EncryptResponse | void
  encryptStreamLoading: boolean
  encryptStreamRequest: EncryptInput | void
  encryptStream: EncryptOutput | void
  encryptFileLoading: boolean
  encryptFileRequest: EncryptFileInput | void
  encryptFile: EncryptFileOutput | void
  decryptLoading: boolean
  decryptRequest: DecryptRequest | void
  decrypt: DecryptResponse | void
  decryptFileLoading: boolean
  decryptFileRequest: DecryptFileInput | void
  decryptFile: DecryptFileOutput | void
  decryptStreamLoading: boolean
  decryptStreamRequest: DecryptInput | void
  decryptStream: DecryptOutput | void
  decryptArmoredStreamLoading: boolean
  decryptArmoredStreamRequest: DecryptInput | void
  decryptArmoredStream: DecryptOutput | void
  signcryptOpenStreamLoading: boolean
  signcryptOpenStreamRequest: DecryptInput | void
  signcryptOpenStream: DecryptOutput | void
  signcryptOpenArmoredStreamLoading: boolean
  signcryptOpenArmoredStreamRequest: DecryptInput | void
  signcryptOpenArmoredStream: DecryptOutput | void
  sigchainLoading: boolean
  sigchainRequest: SigchainRequest | void
  sigchain: SigchainResponse | void
  statementLoading: boolean
  statementRequest: StatementRequest | void
  statement: StatementResponse | void
  statementCreateLoading: boolean
  statementCreateRequest: StatementCreateRequest | void
  statementCreate: StatementCreateResponse | void
  statementRevokeLoading: boolean
  statementRevokeRequest: StatementRevokeRequest | void
  statementRevoke: StatementRevokeResponse | void
  userLoading: boolean
  userRequest: UserRequest | void
  user: UserResponse | void
  userSearchLoading: boolean
  userSearchRequest: UserSearchRequest | void
  userSearch: UserSearchResponse | void
  userServiceLoading: boolean
  userServiceRequest: UserServiceRequest | void
  userService: UserServiceResponse | void
  userSignLoading: boolean
  userSignRequest: UserSignRequest | void
  userSign: UserSignResponse | void
  userAddLoading: boolean
  userAddRequest: UserAddRequest | void
  userAdd: UserAddResponse | void
  itemLoading: boolean
  itemRequest: ItemRequest | void
  item: ItemResponse | void
  itemsLoading: boolean
  itemsRequest: ItemsRequest | void
  items: ItemsResponse | void
  pullLoading: boolean
  pullRequest: PullRequest | void
  pull: PullResponse | void
  pushLoading: boolean
  pushRequest: PushRequest | void
  push: PushResponse | void
  configLoading: boolean
  configRequest: ConfigRequest | void
  config: ConfigResponse | void
  configSetLoading: boolean
  configSetRequest: ConfigSetRequest | void
  configSet: ConfigSetResponse | void
  authSetupLoading: boolean
  authSetupRequest: AuthSetupRequest | void
  authSetup: AuthSetupResponse | void
  authUnlockLoading: boolean
  authUnlockRequest: AuthUnlockRequest | void
  authUnlock: AuthUnlockResponse | void
  authLockLoading: boolean
  authLockRequest: AuthLockRequest | void
  authLock: AuthLockResponse | void
  runtimeStatusLoading: boolean
  runtimeStatusRequest: RuntimeStatusRequest | void
  runtimeStatus: RuntimeStatusResponse | void
  randLoading: boolean
  randRequest: RandRequest | void
  rand: RandResponse | void
  collectionsLoading: boolean
  collectionsRequest: CollectionsRequest | void
  collections: CollectionsResponse | void
  documentsLoading: boolean
  documentsRequest: DocumentsRequest | void
  documents: DocumentsResponse | void
  documentDeleteLoading: boolean
  documentDeleteRequest: DocumentDeleteRequest | void
  documentDelete: DocumentDeleteResponse | void
  inboxLoading: boolean
  inboxRequest: InboxRequest | void
  inbox: InboxResponse | void
  messagePrepareLoading: boolean
  messagePrepareRequest: MessagePrepareRequest | void
  messagePrepare: MessagePrepareResponse | void
  messageCreateLoading: boolean
  messageCreateRequest: MessageCreateRequest | void
  messageCreate: MessageCreateResponse | void
  messagesLoading: boolean
  messagesRequest: MessagesRequest | void
  messages: MessagesResponse | void
  watchLoading: boolean
  watchRequest: WatchRequest | void
  watch: WatchEvent | void
}

const initialState: RPCState = {
  keyGenerateLoading: false,
  keyGenerateRequest: null,
  keyGenerate: null,
  keysLoading: false,
  keysRequest: null,
  keys: null,
  keyLoading: false,
  keyRequest: null,
  key: null,
  keyImportLoading: false,
  keyImportRequest: null,
  keyImport: null,
  keyExportLoading: false,
  keyExportRequest: null,
  keyExport: null,
  keyRemoveLoading: false,
  keyRemoveRequest: null,
  keyRemove: null,
  signLoading: false,
  signRequest: null,
  sign: null,
  signFileLoading: false,
  signFileRequest: null,
  signFile: null,
  signStreamLoading: false,
  signStreamRequest: null,
  signStream: null,
  verifyLoading: false,
  verifyRequest: null,
  verify: null,
  verifyFileLoading: false,
  verifyFileRequest: null,
  verifyFile: null,
  verifyStreamLoading: false,
  verifyStreamRequest: null,
  verifyStream: null,
  verifyArmoredStreamLoading: false,
  verifyArmoredStreamRequest: null,
  verifyArmoredStream: null,
  encryptLoading: false,
  encryptRequest: null,
  encrypt: null,
  encryptStreamLoading: false,
  encryptStreamRequest: null,
  encryptStream: null,
  encryptFileLoading: false,
  encryptFileRequest: null,
  encryptFile: null,
  decryptLoading: false,
  decryptRequest: null,
  decrypt: null,
  decryptFileLoading: false,
  decryptFileRequest: null,
  decryptFile: null,
  decryptStreamLoading: false,
  decryptStreamRequest: null,
  decryptStream: null,
  decryptArmoredStreamLoading: false,
  decryptArmoredStreamRequest: null,
  decryptArmoredStream: null,
  signcryptOpenStreamLoading: false,
  signcryptOpenStreamRequest: null,
  signcryptOpenStream: null,
  signcryptOpenArmoredStreamLoading: false,
  signcryptOpenArmoredStreamRequest: null,
  signcryptOpenArmoredStream: null,
  sigchainLoading: false,
  sigchainRequest: null,
  sigchain: null,
  statementLoading: false,
  statementRequest: null,
  statement: null,
  statementCreateLoading: false,
  statementCreateRequest: null,
  statementCreate: null,
  statementRevokeLoading: false,
  statementRevokeRequest: null,
  statementRevoke: null,
  userLoading: false,
  userRequest: null,
  user: null,
  userSearchLoading: false,
  userSearchRequest: null,
  userSearch: null,
  userServiceLoading: false,
  userServiceRequest: null,
  userService: null,
  userSignLoading: false,
  userSignRequest: null,
  userSign: null,
  userAddLoading: false,
  userAddRequest: null,
  userAdd: null,
  itemLoading: false,
  itemRequest: null,
  item: null,
  itemsLoading: false,
  itemsRequest: null,
  items: null,
  pullLoading: false,
  pullRequest: null,
  pull: null,
  pushLoading: false,
  pushRequest: null,
  push: null,
  configLoading: false,
  configRequest: null,
  config: null,
  configSetLoading: false,
  configSetRequest: null,
  configSet: null,
  authSetupLoading: false,
  authSetupRequest: null,
  authSetup: null,
  authUnlockLoading: false,
  authUnlockRequest: null,
  authUnlock: null,
  authLockLoading: false,
  authLockRequest: null,
  authLock: null,
  runtimeStatusLoading: false,
  runtimeStatusRequest: null,
  runtimeStatus: null,
  randLoading: false,
  randRequest: null,
  rand: null,
  collectionsLoading: false,
  collectionsRequest: null,
  collections: null,
  documentsLoading: false,
  documentsRequest: null,
  documents: null,
  documentDeleteLoading: false,
  documentDeleteRequest: null,
  documentDelete: null,
  inboxLoading: false,
  inboxRequest: null,
  inbox: null,
  messagePrepareLoading: false,
  messagePrepareRequest: null,
  messagePrepare: null,
  messageCreateLoading: false,
  messageCreateRequest: null,
  messageCreate: null,
  messagesLoading: false,
  messagesRequest: null,
  messages: null,
  watchLoading: false,
  watchRequest: null,
  watch: null,
}

export const reducer = (state: RPCState = initialState, action: any) => {
  switch (action.type) {
    case 'KEYS_KEY_GENERATE_REQUEST': {
      return {
        ...state,
        keyGenerateLoading: false,
        keyGenerateRequest: action.payload,
      }
    }
    case 'KEYS_KEY_GENERATE_RESPONSE': {
      return {
        ...state,
        keyGenerateLoading: false,
        keyGenerateRequest: null,
        keyGenerate: action.payload,
      }
    }

    case 'KEYS_KEYS_REQUEST': {
      return {
        ...state,
        keysLoading: false,
        keysRequest: action.payload,
      }
    }
    case 'KEYS_KEYS_RESPONSE': {
      return {
        ...state,
        keysLoading: false,
        keysRequest: null,
        keys: action.payload,
      }
    }

    case 'KEYS_KEY_REQUEST': {
      return {
        ...state,
        keyLoading: false,
        keyRequest: action.payload,
      }
    }
    case 'KEYS_KEY_RESPONSE': {
      return {
        ...state,
        keyLoading: false,
        keyRequest: null,
        key: action.payload,
      }
    }

    case 'KEYS_KEY_IMPORT_REQUEST': {
      return {
        ...state,
        keyImportLoading: false,
        keyImportRequest: action.payload,
      }
    }
    case 'KEYS_KEY_IMPORT_RESPONSE': {
      return {
        ...state,
        keyImportLoading: false,
        keyImportRequest: null,
        keyImport: action.payload,
      }
    }

    case 'KEYS_KEY_EXPORT_REQUEST': {
      return {
        ...state,
        keyExportLoading: false,
        keyExportRequest: action.payload,
      }
    }
    case 'KEYS_KEY_EXPORT_RESPONSE': {
      return {
        ...state,
        keyExportLoading: false,
        keyExportRequest: null,
        keyExport: action.payload,
      }
    }

    case 'KEYS_KEY_REMOVE_REQUEST': {
      return {
        ...state,
        keyRemoveLoading: false,
        keyRemoveRequest: action.payload,
      }
    }
    case 'KEYS_KEY_REMOVE_RESPONSE': {
      return {
        ...state,
        keyRemoveLoading: false,
        keyRemoveRequest: null,
        keyRemove: action.payload,
      }
    }

    case 'KEYS_SIGN_REQUEST': {
      return {
        ...state,
        signLoading: false,
        signRequest: action.payload,
      }
    }
    case 'KEYS_SIGN_RESPONSE': {
      return {
        ...state,
        signLoading: false,
        signRequest: null,
        sign: action.payload,
      }
    }

    case 'KEYS_SIGN_FILE_REQUEST': {
      return {
        ...state,
        signFileLoading: false,
        signFileRequest: action.payload,
      }
    }
    case 'KEYS_SIGN_FILE_RESPONSE': {
      return {
        ...state,
        signFileLoading: false,
        signFileRequest: null,
        signFile: action.payload,
      }
    }

    case 'KEYS_SIGN_STREAM_REQUEST': {
      return {
        ...state,
        signStreamLoading: false,
        signStreamRequest: action.payload,
      }
    }
    case 'KEYS_SIGN_STREAM_RESPONSE': {
      return {
        ...state,
        signStreamLoading: false,
        signStreamRequest: null,
        signStream: action.payload,
      }
    }

    case 'KEYS_VERIFY_REQUEST': {
      return {
        ...state,
        verifyLoading: false,
        verifyRequest: action.payload,
      }
    }
    case 'KEYS_VERIFY_RESPONSE': {
      return {
        ...state,
        verifyLoading: false,
        verifyRequest: null,
        verify: action.payload,
      }
    }

    case 'KEYS_VERIFY_FILE_REQUEST': {
      return {
        ...state,
        verifyFileLoading: false,
        verifyFileRequest: action.payload,
      }
    }
    case 'KEYS_VERIFY_FILE_RESPONSE': {
      return {
        ...state,
        verifyFileLoading: false,
        verifyFileRequest: null,
        verifyFile: action.payload,
      }
    }

    case 'KEYS_VERIFY_STREAM_REQUEST': {
      return {
        ...state,
        verifyStreamLoading: false,
        verifyStreamRequest: action.payload,
      }
    }
    case 'KEYS_VERIFY_STREAM_RESPONSE': {
      return {
        ...state,
        verifyStreamLoading: false,
        verifyStreamRequest: null,
        verifyStream: action.payload,
      }
    }

    case 'KEYS_VERIFY_ARMORED_STREAM_REQUEST': {
      return {
        ...state,
        verifyArmoredStreamLoading: false,
        verifyArmoredStreamRequest: action.payload,
      }
    }
    case 'KEYS_VERIFY_ARMORED_STREAM_RESPONSE': {
      return {
        ...state,
        verifyArmoredStreamLoading: false,
        verifyArmoredStreamRequest: null,
        verifyArmoredStream: action.payload,
      }
    }

    case 'KEYS_ENCRYPT_REQUEST': {
      return {
        ...state,
        encryptLoading: false,
        encryptRequest: action.payload,
      }
    }
    case 'KEYS_ENCRYPT_RESPONSE': {
      return {
        ...state,
        encryptLoading: false,
        encryptRequest: null,
        encrypt: action.payload,
      }
    }

    case 'KEYS_ENCRYPT_STREAM_REQUEST': {
      return {
        ...state,
        encryptStreamLoading: false,
        encryptStreamRequest: action.payload,
      }
    }
    case 'KEYS_ENCRYPT_STREAM_RESPONSE': {
      return {
        ...state,
        encryptStreamLoading: false,
        encryptStreamRequest: null,
        encryptStream: action.payload,
      }
    }

    case 'KEYS_ENCRYPT_FILE_REQUEST': {
      return {
        ...state,
        encryptFileLoading: false,
        encryptFileRequest: action.payload,
      }
    }
    case 'KEYS_ENCRYPT_FILE_RESPONSE': {
      return {
        ...state,
        encryptFileLoading: false,
        encryptFileRequest: null,
        encryptFile: action.payload,
      }
    }

    case 'KEYS_DECRYPT_REQUEST': {
      return {
        ...state,
        decryptLoading: false,
        decryptRequest: action.payload,
      }
    }
    case 'KEYS_DECRYPT_RESPONSE': {
      return {
        ...state,
        decryptLoading: false,
        decryptRequest: null,
        decrypt: action.payload,
      }
    }

    case 'KEYS_DECRYPT_FILE_REQUEST': {
      return {
        ...state,
        decryptFileLoading: false,
        decryptFileRequest: action.payload,
      }
    }
    case 'KEYS_DECRYPT_FILE_RESPONSE': {
      return {
        ...state,
        decryptFileLoading: false,
        decryptFileRequest: null,
        decryptFile: action.payload,
      }
    }

    case 'KEYS_DECRYPT_STREAM_REQUEST': {
      return {
        ...state,
        decryptStreamLoading: false,
        decryptStreamRequest: action.payload,
      }
    }
    case 'KEYS_DECRYPT_STREAM_RESPONSE': {
      return {
        ...state,
        decryptStreamLoading: false,
        decryptStreamRequest: null,
        decryptStream: action.payload,
      }
    }

    case 'KEYS_DECRYPT_ARMORED_STREAM_REQUEST': {
      return {
        ...state,
        decryptArmoredStreamLoading: false,
        decryptArmoredStreamRequest: action.payload,
      }
    }
    case 'KEYS_DECRYPT_ARMORED_STREAM_RESPONSE': {
      return {
        ...state,
        decryptArmoredStreamLoading: false,
        decryptArmoredStreamRequest: null,
        decryptArmoredStream: action.payload,
      }
    }

    case 'KEYS_SIGNCRYPT_OPEN_STREAM_REQUEST': {
      return {
        ...state,
        signcryptOpenStreamLoading: false,
        signcryptOpenStreamRequest: action.payload,
      }
    }
    case 'KEYS_SIGNCRYPT_OPEN_STREAM_RESPONSE': {
      return {
        ...state,
        signcryptOpenStreamLoading: false,
        signcryptOpenStreamRequest: null,
        signcryptOpenStream: action.payload,
      }
    }

    case 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM_REQUEST': {
      return {
        ...state,
        signcryptOpenArmoredStreamLoading: false,
        signcryptOpenArmoredStreamRequest: action.payload,
      }
    }
    case 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM_RESPONSE': {
      return {
        ...state,
        signcryptOpenArmoredStreamLoading: false,
        signcryptOpenArmoredStreamRequest: null,
        signcryptOpenArmoredStream: action.payload,
      }
    }

    case 'KEYS_SIGCHAIN_REQUEST': {
      return {
        ...state,
        sigchainLoading: false,
        sigchainRequest: action.payload,
      }
    }
    case 'KEYS_SIGCHAIN_RESPONSE': {
      return {
        ...state,
        sigchainLoading: false,
        sigchainRequest: null,
        sigchain: action.payload,
      }
    }

    case 'KEYS_STATEMENT_REQUEST': {
      return {
        ...state,
        statementLoading: false,
        statementRequest: action.payload,
      }
    }
    case 'KEYS_STATEMENT_RESPONSE': {
      return {
        ...state,
        statementLoading: false,
        statementRequest: null,
        statement: action.payload,
      }
    }

    case 'KEYS_STATEMENT_CREATE_REQUEST': {
      return {
        ...state,
        statementCreateLoading: false,
        statementCreateRequest: action.payload,
      }
    }
    case 'KEYS_STATEMENT_CREATE_RESPONSE': {
      return {
        ...state,
        statementCreateLoading: false,
        statementCreateRequest: null,
        statementCreate: action.payload,
      }
    }

    case 'KEYS_STATEMENT_REVOKE_REQUEST': {
      return {
        ...state,
        statementRevokeLoading: false,
        statementRevokeRequest: action.payload,
      }
    }
    case 'KEYS_STATEMENT_REVOKE_RESPONSE': {
      return {
        ...state,
        statementRevokeLoading: false,
        statementRevokeRequest: null,
        statementRevoke: action.payload,
      }
    }

    case 'KEYS_USER_REQUEST': {
      return {
        ...state,
        userLoading: false,
        userRequest: action.payload,
      }
    }
    case 'KEYS_USER_RESPONSE': {
      return {
        ...state,
        userLoading: false,
        userRequest: null,
        user: action.payload,
      }
    }

    case 'KEYS_USER_SEARCH_REQUEST': {
      return {
        ...state,
        userSearchLoading: false,
        userSearchRequest: action.payload,
      }
    }
    case 'KEYS_USER_SEARCH_RESPONSE': {
      return {
        ...state,
        userSearchLoading: false,
        userSearchRequest: null,
        userSearch: action.payload,
      }
    }

    case 'KEYS_USER_SERVICE_REQUEST': {
      return {
        ...state,
        userServiceLoading: false,
        userServiceRequest: action.payload,
      }
    }
    case 'KEYS_USER_SERVICE_RESPONSE': {
      return {
        ...state,
        userServiceLoading: false,
        userServiceRequest: null,
        userService: action.payload,
      }
    }

    case 'KEYS_USER_SIGN_REQUEST': {
      return {
        ...state,
        userSignLoading: false,
        userSignRequest: action.payload,
      }
    }
    case 'KEYS_USER_SIGN_RESPONSE': {
      return {
        ...state,
        userSignLoading: false,
        userSignRequest: null,
        userSign: action.payload,
      }
    }

    case 'KEYS_USER_ADD_REQUEST': {
      return {
        ...state,
        userAddLoading: false,
        userAddRequest: action.payload,
      }
    }
    case 'KEYS_USER_ADD_RESPONSE': {
      return {
        ...state,
        userAddLoading: false,
        userAddRequest: null,
        userAdd: action.payload,
      }
    }

    case 'KEYS_ITEM_REQUEST': {
      return {
        ...state,
        itemLoading: false,
        itemRequest: action.payload,
      }
    }
    case 'KEYS_ITEM_RESPONSE': {
      return {
        ...state,
        itemLoading: false,
        itemRequest: null,
        item: action.payload,
      }
    }

    case 'KEYS_ITEMS_REQUEST': {
      return {
        ...state,
        itemsLoading: false,
        itemsRequest: action.payload,
      }
    }
    case 'KEYS_ITEMS_RESPONSE': {
      return {
        ...state,
        itemsLoading: false,
        itemsRequest: null,
        items: action.payload,
      }
    }

    case 'KEYS_PULL_REQUEST': {
      return {
        ...state,
        pullLoading: false,
        pullRequest: action.payload,
      }
    }
    case 'KEYS_PULL_RESPONSE': {
      return {
        ...state,
        pullLoading: false,
        pullRequest: null,
        pull: action.payload,
      }
    }

    case 'KEYS_PUSH_REQUEST': {
      return {
        ...state,
        pushLoading: false,
        pushRequest: action.payload,
      }
    }
    case 'KEYS_PUSH_RESPONSE': {
      return {
        ...state,
        pushLoading: false,
        pushRequest: null,
        push: action.payload,
      }
    }

    case 'KEYS_CONFIG_REQUEST': {
      return {
        ...state,
        configLoading: false,
        configRequest: action.payload,
      }
    }
    case 'KEYS_CONFIG_RESPONSE': {
      return {
        ...state,
        configLoading: false,
        configRequest: null,
        config: action.payload,
      }
    }

    case 'KEYS_CONFIG_SET_REQUEST': {
      return {
        ...state,
        configSetLoading: false,
        configSetRequest: action.payload,
      }
    }
    case 'KEYS_CONFIG_SET_RESPONSE': {
      return {
        ...state,
        configSetLoading: false,
        configSetRequest: null,
        configSet: action.payload,
      }
    }

    case 'KEYS_AUTH_SETUP_REQUEST': {
      return {
        ...state,
        authSetupLoading: false,
        authSetupRequest: action.payload,
      }
    }
    case 'KEYS_AUTH_SETUP_RESPONSE': {
      return {
        ...state,
        authSetupLoading: false,
        authSetupRequest: null,
        authSetup: action.payload,
      }
    }

    case 'KEYS_AUTH_UNLOCK_REQUEST': {
      return {
        ...state,
        authUnlockLoading: false,
        authUnlockRequest: action.payload,
      }
    }
    case 'KEYS_AUTH_UNLOCK_RESPONSE': {
      return {
        ...state,
        authUnlockLoading: false,
        authUnlockRequest: null,
        authUnlock: action.payload,
      }
    }

    case 'KEYS_AUTH_LOCK_REQUEST': {
      return {
        ...state,
        authLockLoading: false,
        authLockRequest: action.payload,
      }
    }
    case 'KEYS_AUTH_LOCK_RESPONSE': {
      return {
        ...state,
        authLockLoading: false,
        authLockRequest: null,
        authLock: action.payload,
      }
    }

    case 'KEYS_RUNTIME_STATUS_REQUEST': {
      return {
        ...state,
        runtimeStatusLoading: false,
        runtimeStatusRequest: action.payload,
      }
    }
    case 'KEYS_RUNTIME_STATUS_RESPONSE': {
      return {
        ...state,
        runtimeStatusLoading: false,
        runtimeStatusRequest: null,
        runtimeStatus: action.payload,
      }
    }

    case 'KEYS_RAND_REQUEST': {
      return {
        ...state,
        randLoading: false,
        randRequest: action.payload,
      }
    }
    case 'KEYS_RAND_RESPONSE': {
      return {
        ...state,
        randLoading: false,
        randRequest: null,
        rand: action.payload,
      }
    }

    case 'KEYS_COLLECTIONS_REQUEST': {
      return {
        ...state,
        collectionsLoading: false,
        collectionsRequest: action.payload,
      }
    }
    case 'KEYS_COLLECTIONS_RESPONSE': {
      return {
        ...state,
        collectionsLoading: false,
        collectionsRequest: null,
        collections: action.payload,
      }
    }

    case 'KEYS_DOCUMENTS_REQUEST': {
      return {
        ...state,
        documentsLoading: false,
        documentsRequest: action.payload,
      }
    }
    case 'KEYS_DOCUMENTS_RESPONSE': {
      return {
        ...state,
        documentsLoading: false,
        documentsRequest: null,
        documents: action.payload,
      }
    }

    case 'KEYS_DOCUMENT_DELETE_REQUEST': {
      return {
        ...state,
        documentDeleteLoading: false,
        documentDeleteRequest: action.payload,
      }
    }
    case 'KEYS_DOCUMENT_DELETE_RESPONSE': {
      return {
        ...state,
        documentDeleteLoading: false,
        documentDeleteRequest: null,
        documentDelete: action.payload,
      }
    }

    case 'KEYS_INBOX_REQUEST': {
      return {
        ...state,
        inboxLoading: false,
        inboxRequest: action.payload,
      }
    }
    case 'KEYS_INBOX_RESPONSE': {
      return {
        ...state,
        inboxLoading: false,
        inboxRequest: null,
        inbox: action.payload,
      }
    }

    case 'KEYS_MESSAGE_PREPARE_REQUEST': {
      return {
        ...state,
        messagePrepareLoading: false,
        messagePrepareRequest: action.payload,
      }
    }
    case 'KEYS_MESSAGE_PREPARE_RESPONSE': {
      return {
        ...state,
        messagePrepareLoading: false,
        messagePrepareRequest: null,
        messagePrepare: action.payload,
      }
    }

    case 'KEYS_MESSAGE_CREATE_REQUEST': {
      return {
        ...state,
        messageCreateLoading: false,
        messageCreateRequest: action.payload,
      }
    }
    case 'KEYS_MESSAGE_CREATE_RESPONSE': {
      return {
        ...state,
        messageCreateLoading: false,
        messageCreateRequest: null,
        messageCreate: action.payload,
      }
    }

    case 'KEYS_MESSAGES_REQUEST': {
      return {
        ...state,
        messagesLoading: false,
        messagesRequest: action.payload,
      }
    }
    case 'KEYS_MESSAGES_RESPONSE': {
      return {
        ...state,
        messagesLoading: false,
        messagesRequest: null,
        messages: action.payload,
      }
    }

    case 'KEYS_WATCH_REQUEST': {
      return {
        ...state,
        watchLoading: false,
        watchRequest: action.payload,
      }
    }
    case 'KEYS_WATCH_RESPONSE': {
      return {
        ...state,
        watchLoading: false,
        watchRequest: null,
        watch: action.payload,
      }
    }
    default:
      return state
  }
}

export type ErrFn = (err: RPCError) => void
export type ErrHandler = (err: RPCError, errFn: ErrFn | void) => void
var errHandler: ErrHandler | void = null
export const setErrHandler = (eh: ErrHandler | void) => {
  errHandler = eh
}
