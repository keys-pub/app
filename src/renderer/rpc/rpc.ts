// Code generated by protoc-gen-tsrpc DO NOT EDIT.
// InputID: d43484ebcc15d2728dbed19a7166f1c5fef3f658
import {client} from './client'

import {
  KeyGenerateRequest,
  KeyGenerateResponse,
  KeysRequest,
  KeysResponse,
  KeyRequest,
  KeyResponse,
  KeyImportRequest,
  KeyImportResponse,
  KeyExportRequest,
  KeyExportResponse,
  KeyRemoveRequest,
  KeyRemoveResponse,
  SignRequest,
  SignResponse,
  SignFileInput,
  SignFileOutput,
  SignInput,
  SignOutput,
  VerifyRequest,
  VerifyResponse,
  VerifyFileInput,
  VerifyFileOutput,
  VerifyInput,
  VerifyOutput,
  EncryptRequest,
  EncryptResponse,
  EncryptInput,
  EncryptOutput,
  EncryptFileInput,
  EncryptFileOutput,
  DecryptRequest,
  DecryptResponse,
  DecryptFileInput,
  DecryptFileOutput,
  DecryptInput,
  DecryptOutput,
  SigchainRequest,
  SigchainResponse,
  StatementRequest,
  StatementResponse,
  StatementCreateRequest,
  StatementCreateResponse,
  StatementRevokeRequest,
  StatementRevokeResponse,
  UserSearchRequest,
  UserSearchResponse,
  UserServiceRequest,
  UserServiceResponse,
  UserSignRequest,
  UserSignResponse,
  UserAddRequest,
  UserAddResponse,
  ItemRequest,
  ItemResponse,
  ItemsRequest,
  ItemsResponse,
  PullRequest,
  PullResponse,
  PushRequest,
  PushResponse,
  ConfigRequest,
  ConfigResponse,
  ConfigSetRequest,
  ConfigSetResponse,
  AppStatusRequest,
  AppStatusResponse,
  AuthSetupRequest,
  AuthSetupResponse,
  AuthUnlockRequest,
  AuthUnlockResponse,
  AuthLockRequest,
  AuthLockResponse,
  RuntimeStatusRequest,
  RuntimeStatusResponse,
  RandRequest,
  RandResponse,
  CollectionsRequest,
  CollectionsResponse,
  DocumentsRequest,
  DocumentsResponse,
  DocumentDeleteRequest,
  DocumentDeleteResponse,
  InboxRequest,
  InboxResponse,
  MessagePrepareRequest,
  MessagePrepareResponse,
  MessageCreateRequest,
  MessageCreateResponse,
  MessagesRequest,
  MessagesResponse,
  WatchRequest,
  WatchEvent
} from './types'

export type RPCError = {
	code: number,
	message: string,
	details: string,
}

export const keyGenerate = (req: KeyGenerateRequest, respFn: ((resp: KeyGenerateResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_GENERATE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyGenerate(req, (err: RPCError|void, resp: KeyGenerateResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_GENERATE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_GENERATE_RESPONSE',
        payload: resp,
      })
    })
  }

export const keys = (req: KeysRequest, respFn: ((resp: KeysResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEYS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keys(req, (err: RPCError|void, resp: KeysResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEYS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEYS_RESPONSE',
        payload: resp,
      })
    })
  }

export const key = (req: KeyRequest, respFn: ((resp: KeyResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.key(req, (err: RPCError|void, resp: KeyResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_RESPONSE',
        payload: resp,
      })
    })
  }

export const keyImport = (req: KeyImportRequest, respFn: ((resp: KeyImportResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_IMPORT_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyImport(req, (err: RPCError|void, resp: KeyImportResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_IMPORT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_IMPORT_RESPONSE',
        payload: resp,
      })
    })
  }

export const keyExport = (req: KeyExportRequest, respFn: ((resp: KeyExportResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_EXPORT_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyExport(req, (err: RPCError|void, resp: KeyExportResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_EXPORT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_EXPORT_RESPONSE',
        payload: resp,
      })
    })
  }

export const keyRemove = (req: KeyRemoveRequest, respFn: ((resp: KeyRemoveResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_REMOVE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyRemove(req, (err: RPCError|void, resp: KeyRemoveResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_REMOVE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_REMOVE_RESPONSE',
        payload: resp,
      })
    })
  }

export const sign = (req: SignRequest, respFn: ((resp: SignResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGN_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.sign(req, (err: RPCError|void, resp: SignResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGN', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGN_RESPONSE',
        payload: resp,
      })
    })
  }

export const signFile = (req: SignFileInput, respFn: ((resp: SignFileOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGN_FILE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.signFile(req, (err: RPCError|void, resp: SignFileOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGN_FILE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGN_FILE_RESPONSE',
        payload: resp,
      })
    })
  }

export const signStream = (req: SignInput, respFn: ((resp: SignOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGN_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.signStream(req, (err: RPCError|void, resp: SignOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGN_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGN_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const verify = (req: VerifyRequest, respFn: ((resp: VerifyResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.verify(req, (err: RPCError|void, resp: VerifyResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_VERIFY_RESPONSE',
        payload: resp,
      })
    })
  }

export const verifyFile = (req: VerifyFileInput, respFn: ((resp: VerifyFileOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_FILE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.verifyFile(req, (err: RPCError|void, resp: VerifyFileOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY_FILE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_VERIFY_FILE_RESPONSE',
        payload: resp,
      })
    })
  }

export const verifyStream = (req: VerifyInput, respFn: ((resp: VerifyOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.verifyStream(req, (err: RPCError|void, resp: VerifyOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_VERIFY_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const verifyArmoredStream = (req: VerifyInput, respFn: ((resp: VerifyOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_ARMORED_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.verifyArmoredStream(req, (err: RPCError|void, resp: VerifyOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY_ARMORED_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_VERIFY_ARMORED_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const encrypt = (req: EncryptRequest, respFn: ((resp: EncryptResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ENCRYPT_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.encrypt(req, (err: RPCError|void, resp: EncryptResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ENCRYPT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_ENCRYPT_RESPONSE',
        payload: resp,
      })
    })
  }

export const encryptStream = (req: EncryptInput, respFn: ((resp: EncryptOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ENCRYPT_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.encryptStream(req, (err: RPCError|void, resp: EncryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ENCRYPT_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_ENCRYPT_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const encryptFile = (req: EncryptFileInput, respFn: ((resp: EncryptFileOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ENCRYPT_FILE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.encryptFile(req, (err: RPCError|void, resp: EncryptFileOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ENCRYPT_FILE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_ENCRYPT_FILE_RESPONSE',
        payload: resp,
      })
    })
  }

export const decrypt = (req: DecryptRequest, respFn: ((resp: DecryptResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.decrypt(req, (err: RPCError|void, resp: DecryptResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DECRYPT_RESPONSE',
        payload: resp,
      })
    })
  }

export const decryptFile = (req: DecryptFileInput, respFn: ((resp: DecryptFileOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_FILE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.decryptFile(req, (err: RPCError|void, resp: DecryptFileOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT_FILE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DECRYPT_FILE_RESPONSE',
        payload: resp,
      })
    })
  }

export const decryptStream = (req: DecryptInput, respFn: ((resp: DecryptOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.decryptStream(req, (err: RPCError|void, resp: DecryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DECRYPT_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const decryptArmoredStream = (req: DecryptInput, respFn: ((resp: DecryptOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_ARMORED_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.decryptArmoredStream(req, (err: RPCError|void, resp: DecryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT_ARMORED_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DECRYPT_ARMORED_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const signcryptOpenStream = (req: DecryptInput, respFn: ((resp: DecryptOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGNCRYPT_OPEN_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.signcryptOpenStream(req, (err: RPCError|void, resp: DecryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGNCRYPT_OPEN_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGNCRYPT_OPEN_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const signcryptOpenArmoredStream = (req: DecryptInput, respFn: ((resp: DecryptOutput) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.signcryptOpenArmoredStream(req, (err: RPCError|void, resp: DecryptOutput | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const sigchain = (req: SigchainRequest, respFn: ((resp: SigchainResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGCHAIN_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.sigchain(req, (err: RPCError|void, resp: SigchainResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGCHAIN', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGCHAIN_RESPONSE',
        payload: resp,
      })
    })
  }

export const statement = (req: StatementRequest, respFn: ((resp: StatementResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_STATEMENT_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.statement(req, (err: RPCError|void, resp: StatementResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_STATEMENT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_STATEMENT_RESPONSE',
        payload: resp,
      })
    })
  }

export const statementCreate = (req: StatementCreateRequest, respFn: ((resp: StatementCreateResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_STATEMENT_CREATE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.statementCreate(req, (err: RPCError|void, resp: StatementCreateResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_STATEMENT_CREATE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_STATEMENT_CREATE_RESPONSE',
        payload: resp,
      })
    })
  }

export const statementRevoke = (req: StatementRevokeRequest, respFn: ((resp: StatementRevokeResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_STATEMENT_REVOKE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.statementRevoke(req, (err: RPCError|void, resp: StatementRevokeResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_STATEMENT_REVOKE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_STATEMENT_REVOKE_RESPONSE',
        payload: resp,
      })
    })
  }

export const userSearch = (req: UserSearchRequest, respFn: ((resp: UserSearchResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_SEARCH_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.userSearch(req, (err: RPCError|void, resp: UserSearchResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_SEARCH', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_USER_SEARCH_RESPONSE',
        payload: resp,
      })
    })
  }

export const userService = (req: UserServiceRequest, respFn: ((resp: UserServiceResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_SERVICE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.userService(req, (err: RPCError|void, resp: UserServiceResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_SERVICE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_USER_SERVICE_RESPONSE',
        payload: resp,
      })
    })
  }

export const userSign = (req: UserSignRequest, respFn: ((resp: UserSignResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_SIGN_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.userSign(req, (err: RPCError|void, resp: UserSignResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_SIGN', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_USER_SIGN_RESPONSE',
        payload: resp,
      })
    })
  }

export const userAdd = (req: UserAddRequest, respFn: ((resp: UserAddResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_ADD_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.userAdd(req, (err: RPCError|void, resp: UserAddResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_ADD', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_USER_ADD_RESPONSE',
        payload: resp,
      })
    })
  }

export const item = (req: ItemRequest, respFn: ((resp: ItemResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ITEM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.item(req, (err: RPCError|void, resp: ItemResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ITEM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_ITEM_RESPONSE',
        payload: resp,
      })
    })
  }

export const items = (req: ItemsRequest, respFn: ((resp: ItemsResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ITEMS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.items(req, (err: RPCError|void, resp: ItemsResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ITEMS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_ITEMS_RESPONSE',
        payload: resp,
      })
    })
  }

export const pull = (req: PullRequest, respFn: ((resp: PullResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_PULL_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.pull(req, (err: RPCError|void, resp: PullResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_PULL', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_PULL_RESPONSE',
        payload: resp,
      })
    })
  }

export const push = (req: PushRequest, respFn: ((resp: PushResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_PUSH_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.push(req, (err: RPCError|void, resp: PushResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_PUSH', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_PUSH_RESPONSE',
        payload: resp,
      })
    })
  }

export const config = (req: ConfigRequest, respFn: ((resp: ConfigResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_CONFIG_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.config(req, (err: RPCError|void, resp: ConfigResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_CONFIG', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_CONFIG_RESPONSE',
        payload: resp,
      })
    })
  }

export const configSet = (req: ConfigSetRequest, respFn: ((resp: ConfigSetResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_CONFIG_SET_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.configSet(req, (err: RPCError|void, resp: ConfigSetResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_CONFIG_SET', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_CONFIG_SET_RESPONSE',
        payload: resp,
      })
    })
  }

export const appStatus = (req: AppStatusRequest, respFn: ((resp: AppStatusResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_APP_STATUS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.appStatus(req, (err: RPCError|void, resp: AppStatusResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_APP_STATUS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_APP_STATUS_RESPONSE',
        payload: resp,
      })
    })
  }

export const authSetup = (req: AuthSetupRequest, respFn: ((resp: AuthSetupResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_AUTH_SETUP_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.authSetup(req, (err: RPCError|void, resp: AuthSetupResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_AUTH_SETUP', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_AUTH_SETUP_RESPONSE',
        payload: resp,
      })
    })
  }

export const authUnlock = (req: AuthUnlockRequest, respFn: ((resp: AuthUnlockResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_AUTH_UNLOCK_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.authUnlock(req, (err: RPCError|void, resp: AuthUnlockResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_AUTH_UNLOCK', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_AUTH_UNLOCK_RESPONSE',
        payload: resp,
      })
    })
  }

export const authLock = (req: AuthLockRequest, respFn: ((resp: AuthLockResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_AUTH_LOCK_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.authLock(req, (err: RPCError|void, resp: AuthLockResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_AUTH_LOCK', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_AUTH_LOCK_RESPONSE',
        payload: resp,
      })
    })
  }

export const runtimeStatus = (req: RuntimeStatusRequest, respFn: ((resp: RuntimeStatusResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_RUNTIME_STATUS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.runtimeStatus(req, (err: RPCError|void, resp: RuntimeStatusResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_RUNTIME_STATUS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_RUNTIME_STATUS_RESPONSE',
        payload: resp,
      })
    })
  }

export const rand = (req: RandRequest, respFn: ((resp: RandResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_RAND_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.rand(req, (err: RPCError|void, resp: RandResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_RAND', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_RAND_RESPONSE',
        payload: resp,
      })
    })
  }

export const collections = (req: CollectionsRequest, respFn: ((resp: CollectionsResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_COLLECTIONS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.collections(req, (err: RPCError|void, resp: CollectionsResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_COLLECTIONS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_COLLECTIONS_RESPONSE',
        payload: resp,
      })
    })
  }

export const documents = (req: DocumentsRequest, respFn: ((resp: DocumentsResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DOCUMENTS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.documents(req, (err: RPCError|void, resp: DocumentsResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DOCUMENTS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DOCUMENTS_RESPONSE',
        payload: resp,
      })
    })
  }

export const documentDelete = (req: DocumentDeleteRequest, respFn: ((resp: DocumentDeleteResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DOCUMENT_DELETE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.documentDelete(req, (err: RPCError|void, resp: DocumentDeleteResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DOCUMENT_DELETE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DOCUMENT_DELETE_RESPONSE',
        payload: resp,
      })
    })
  }

export const inbox = (req: InboxRequest, respFn: ((resp: InboxResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_INBOX_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.inbox(req, (err: RPCError|void, resp: InboxResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_INBOX', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_INBOX_RESPONSE',
        payload: resp,
      })
    })
  }

export const messagePrepare = (req: MessagePrepareRequest, respFn: ((resp: MessagePrepareResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_MESSAGE_PREPARE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.messagePrepare(req, (err: RPCError|void, resp: MessagePrepareResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_MESSAGE_PREPARE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_MESSAGE_PREPARE_RESPONSE',
        payload: resp,
      })
    })
  }

export const messageCreate = (req: MessageCreateRequest, respFn: ((resp: MessageCreateResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_MESSAGE_CREATE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.messageCreate(req, (err: RPCError|void, resp: MessageCreateResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_MESSAGE_CREATE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_MESSAGE_CREATE_RESPONSE',
        payload: resp,
      })
    })
  }

export const messages = (req: MessagesRequest, respFn: ((resp: MessagesResponse) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_MESSAGES_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.messages(req, (err: RPCError|void, resp: MessagesResponse | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_MESSAGES', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_MESSAGES_RESPONSE',
        payload: resp,
      })
    })
  }

export const watch = (req: WatchRequest, respFn: ((resp: WatchEvent) => void) | void, errFn: ErrFn | void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_WATCH_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.watch(req, (err: RPCError|void, resp: WatchEvent | void) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)      
      } 
      if (errHandler) {
        errHandler(err, errFn)
      } else if (!errFn) {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_WATCH', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_WATCH_RESPONSE',
        payload: resp,
      })
    })
  }



export const RPC = {
  keyGenerate,
  keys,
  key,
  keyImport,
  keyExport,
  keyRemove,
  sign,
  signFile,
  signStream,
  verify,
  verifyFile,
  verifyStream,
  verifyArmoredStream,
  encrypt,
  encryptStream,
  encryptFile,
  decrypt,
  decryptFile,
  decryptStream,
  decryptArmoredStream,
  signcryptOpenStream,
  signcryptOpenArmoredStream,
  sigchain,
  statement,
  statementCreate,
  statementRevoke,
  userSearch,
  userService,
  userSign,
  userAdd,
  item,
  items,
  pull,
  push,
  config,
  configSet,
  appStatus,
  authSetup,
  authUnlock,
  authLock,
  runtimeStatus,
  rand,
  collections,
  documents,
  documentDelete,
  inbox,
  messagePrepare,
  messageCreate,
  messages,
  watch
}

export type RPCState = {
  keyGenerateLoading: boolean,
  keyGenerateRequest: KeyGenerateRequest | void,
  keyGenerate: KeyGenerateResponse | void,
  keysLoading: boolean,
  keysRequest: KeysRequest | void,
  keys: KeysResponse | void,
  keyLoading: boolean,
  keyRequest: KeyRequest | void,
  key: KeyResponse | void,
  keyImportLoading: boolean,
  keyImportRequest: KeyImportRequest | void,
  keyImport: KeyImportResponse | void,
  keyExportLoading: boolean,
  keyExportRequest: KeyExportRequest | void,
  keyExport: KeyExportResponse | void,
  keyRemoveLoading: boolean,
  keyRemoveRequest: KeyRemoveRequest | void,
  keyRemove: KeyRemoveResponse | void,
  signLoading: boolean,
  signRequest: SignRequest | void,
  sign: SignResponse | void,
  signFileLoading: boolean,
  signFileRequest: SignFileInput | void,
  signFile: SignFileOutput | void,
  signStreamLoading: boolean,
  signStreamRequest: SignInput | void,
  signStream: SignOutput | void,
  verifyLoading: boolean,
  verifyRequest: VerifyRequest | void,
  verify: VerifyResponse | void,
  verifyFileLoading: boolean,
  verifyFileRequest: VerifyFileInput | void,
  verifyFile: VerifyFileOutput | void,
  verifyStreamLoading: boolean,
  verifyStreamRequest: VerifyInput | void,
  verifyStream: VerifyOutput | void,
  verifyArmoredStreamLoading: boolean,
  verifyArmoredStreamRequest: VerifyInput | void,
  verifyArmoredStream: VerifyOutput | void,
  encryptLoading: boolean,
  encryptRequest: EncryptRequest | void,
  encrypt: EncryptResponse | void,
  encryptStreamLoading: boolean,
  encryptStreamRequest: EncryptInput | void,
  encryptStream: EncryptOutput | void,
  encryptFileLoading: boolean,
  encryptFileRequest: EncryptFileInput | void,
  encryptFile: EncryptFileOutput | void,
  decryptLoading: boolean,
  decryptRequest: DecryptRequest | void,
  decrypt: DecryptResponse | void,
  decryptFileLoading: boolean,
  decryptFileRequest: DecryptFileInput | void,
  decryptFile: DecryptFileOutput | void,
  decryptStreamLoading: boolean,
  decryptStreamRequest: DecryptInput | void,
  decryptStream: DecryptOutput | void,
  decryptArmoredStreamLoading: boolean,
  decryptArmoredStreamRequest: DecryptInput | void,
  decryptArmoredStream: DecryptOutput | void,
  signcryptOpenStreamLoading: boolean,
  signcryptOpenStreamRequest: DecryptInput | void,
  signcryptOpenStream: DecryptOutput | void,
  signcryptOpenArmoredStreamLoading: boolean,
  signcryptOpenArmoredStreamRequest: DecryptInput | void,
  signcryptOpenArmoredStream: DecryptOutput | void,
  sigchainLoading: boolean,
  sigchainRequest: SigchainRequest | void,
  sigchain: SigchainResponse | void,
  statementLoading: boolean,
  statementRequest: StatementRequest | void,
  statement: StatementResponse | void,
  statementCreateLoading: boolean,
  statementCreateRequest: StatementCreateRequest | void,
  statementCreate: StatementCreateResponse | void,
  statementRevokeLoading: boolean,
  statementRevokeRequest: StatementRevokeRequest | void,
  statementRevoke: StatementRevokeResponse | void,
  userSearchLoading: boolean,
  userSearchRequest: UserSearchRequest | void,
  userSearch: UserSearchResponse | void,
  userServiceLoading: boolean,
  userServiceRequest: UserServiceRequest | void,
  userService: UserServiceResponse | void,
  userSignLoading: boolean,
  userSignRequest: UserSignRequest | void,
  userSign: UserSignResponse | void,
  userAddLoading: boolean,
  userAddRequest: UserAddRequest | void,
  userAdd: UserAddResponse | void,
  itemLoading: boolean,
  itemRequest: ItemRequest | void,
  item: ItemResponse | void,
  itemsLoading: boolean,
  itemsRequest: ItemsRequest | void,
  items: ItemsResponse | void,
  pullLoading: boolean,
  pullRequest: PullRequest | void,
  pull: PullResponse | void,
  pushLoading: boolean,
  pushRequest: PushRequest | void,
  push: PushResponse | void,
  configLoading: boolean,
  configRequest: ConfigRequest | void,
  config: ConfigResponse | void,
  configSetLoading: boolean,
  configSetRequest: ConfigSetRequest | void,
  configSet: ConfigSetResponse | void,
  appStatusLoading: boolean,
  appStatusRequest: AppStatusRequest | void,
  appStatus: AppStatusResponse | void,
  authSetupLoading: boolean,
  authSetupRequest: AuthSetupRequest | void,
  authSetup: AuthSetupResponse | void,
  authUnlockLoading: boolean,
  authUnlockRequest: AuthUnlockRequest | void,
  authUnlock: AuthUnlockResponse | void,
  authLockLoading: boolean,
  authLockRequest: AuthLockRequest | void,
  authLock: AuthLockResponse | void,
  runtimeStatusLoading: boolean,
  runtimeStatusRequest: RuntimeStatusRequest | void,
  runtimeStatus: RuntimeStatusResponse | void,
  randLoading: boolean,
  randRequest: RandRequest | void,
  rand: RandResponse | void,
  collectionsLoading: boolean,
  collectionsRequest: CollectionsRequest | void,
  collections: CollectionsResponse | void,
  documentsLoading: boolean,
  documentsRequest: DocumentsRequest | void,
  documents: DocumentsResponse | void,
  documentDeleteLoading: boolean,
  documentDeleteRequest: DocumentDeleteRequest | void,
  documentDelete: DocumentDeleteResponse | void,
  inboxLoading: boolean,
  inboxRequest: InboxRequest | void,
  inbox: InboxResponse | void,
  messagePrepareLoading: boolean,
  messagePrepareRequest: MessagePrepareRequest | void,
  messagePrepare: MessagePrepareResponse | void,
  messageCreateLoading: boolean,
  messageCreateRequest: MessageCreateRequest | void,
  messageCreate: MessageCreateResponse | void,
  messagesLoading: boolean,
  messagesRequest: MessagesRequest | void,
  messages: MessagesResponse | void,
  watchLoading: boolean,
  watchRequest: WatchRequest | void,
  watch: WatchEvent | void
}

const initialState: RPCState = {
  keyGenerateLoading: false,
  keyGenerateRequest: null,
  keyGenerate: null,
  keysLoading: false,
  keysRequest: null,
  keys: null,
  keyLoading: false,
  keyRequest: null,
  key: null,
  keyImportLoading: false,
  keyImportRequest: null,
  keyImport: null,
  keyExportLoading: false,
  keyExportRequest: null,
  keyExport: null,
  keyRemoveLoading: false,
  keyRemoveRequest: null,
  keyRemove: null,
  signLoading: false,
  signRequest: null,
  sign: null,
  signFileLoading: false,
  signFileRequest: null,
  signFile: null,
  signStreamLoading: false,
  signStreamRequest: null,
  signStream: null,
  verifyLoading: false,
  verifyRequest: null,
  verify: null,
  verifyFileLoading: false,
  verifyFileRequest: null,
  verifyFile: null,
  verifyStreamLoading: false,
  verifyStreamRequest: null,
  verifyStream: null,
  verifyArmoredStreamLoading: false,
  verifyArmoredStreamRequest: null,
  verifyArmoredStream: null,
  encryptLoading: false,
  encryptRequest: null,
  encrypt: null,
  encryptStreamLoading: false,
  encryptStreamRequest: null,
  encryptStream: null,
  encryptFileLoading: false,
  encryptFileRequest: null,
  encryptFile: null,
  decryptLoading: false,
  decryptRequest: null,
  decrypt: null,
  decryptFileLoading: false,
  decryptFileRequest: null,
  decryptFile: null,
  decryptStreamLoading: false,
  decryptStreamRequest: null,
  decryptStream: null,
  decryptArmoredStreamLoading: false,
  decryptArmoredStreamRequest: null,
  decryptArmoredStream: null,
  signcryptOpenStreamLoading: false,
  signcryptOpenStreamRequest: null,
  signcryptOpenStream: null,
  signcryptOpenArmoredStreamLoading: false,
  signcryptOpenArmoredStreamRequest: null,
  signcryptOpenArmoredStream: null,
  sigchainLoading: false,
  sigchainRequest: null,
  sigchain: null,
  statementLoading: false,
  statementRequest: null,
  statement: null,
  statementCreateLoading: false,
  statementCreateRequest: null,
  statementCreate: null,
  statementRevokeLoading: false,
  statementRevokeRequest: null,
  statementRevoke: null,
  userSearchLoading: false,
  userSearchRequest: null,
  userSearch: null,
  userServiceLoading: false,
  userServiceRequest: null,
  userService: null,
  userSignLoading: false,
  userSignRequest: null,
  userSign: null,
  userAddLoading: false,
  userAddRequest: null,
  userAdd: null,
  itemLoading: false,
  itemRequest: null,
  item: null,
  itemsLoading: false,
  itemsRequest: null,
  items: null,
  pullLoading: false,
  pullRequest: null,
  pull: null,
  pushLoading: false,
  pushRequest: null,
  push: null,
  configLoading: false,
  configRequest: null,
  config: null,
  configSetLoading: false,
  configSetRequest: null,
  configSet: null,
  appStatusLoading: false,
  appStatusRequest: null,
  appStatus: null,
  authSetupLoading: false,
  authSetupRequest: null,
  authSetup: null,
  authUnlockLoading: false,
  authUnlockRequest: null,
  authUnlock: null,
  authLockLoading: false,
  authLockRequest: null,
  authLock: null,
  runtimeStatusLoading: false,
  runtimeStatusRequest: null,
  runtimeStatus: null,
  randLoading: false,
  randRequest: null,
  rand: null,
  collectionsLoading: false,
  collectionsRequest: null,
  collections: null,
  documentsLoading: false,
  documentsRequest: null,
  documents: null,
  documentDeleteLoading: false,
  documentDeleteRequest: null,
  documentDelete: null,
  inboxLoading: false,
  inboxRequest: null,
  inbox: null,
  messagePrepareLoading: false,
  messagePrepareRequest: null,
  messagePrepare: null,
  messageCreateLoading: false,
  messageCreateRequest: null,
  messageCreate: null,
  messagesLoading: false,
  messagesRequest: null,
  messages: null,
  watchLoading: false,
  watchRequest: null,
  watch: null
}

export const reducer = (state: RPCState = initialState, action: any) => {
  switch (action.type) {
		case 'KEYS_KEY_GENERATE_REQUEST': {
			return {
				...state,
				keyGenerateLoading: false,
				keyGenerateRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_GENERATE_RESPONSE': {
			return {
				...state,
				keyGenerateLoading: false,
				keyGenerateRequest: null,
				keyGenerate: action.payload,
			}
		}
    
		case 'KEYS_KEYS_REQUEST': {
			return {
				...state,
				keysLoading: false,
				keysRequest: action.payload,
		  }
		}
		case 'KEYS_KEYS_RESPONSE': {
			return {
				...state,
				keysLoading: false,
				keysRequest: null,
				keys: action.payload,
			}
		}
    
		case 'KEYS_KEY_REQUEST': {
			return {
				...state,
				keyLoading: false,
				keyRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_RESPONSE': {
			return {
				...state,
				keyLoading: false,
				keyRequest: null,
				key: action.payload,
			}
		}
    
		case 'KEYS_KEY_IMPORT_REQUEST': {
			return {
				...state,
				keyImportLoading: false,
				keyImportRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_IMPORT_RESPONSE': {
			return {
				...state,
				keyImportLoading: false,
				keyImportRequest: null,
				keyImport: action.payload,
			}
		}
    
		case 'KEYS_KEY_EXPORT_REQUEST': {
			return {
				...state,
				keyExportLoading: false,
				keyExportRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_EXPORT_RESPONSE': {
			return {
				...state,
				keyExportLoading: false,
				keyExportRequest: null,
				keyExport: action.payload,
			}
		}
    
		case 'KEYS_KEY_REMOVE_REQUEST': {
			return {
				...state,
				keyRemoveLoading: false,
				keyRemoveRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_REMOVE_RESPONSE': {
			return {
				...state,
				keyRemoveLoading: false,
				keyRemoveRequest: null,
				keyRemove: action.payload,
			}
		}
    
		case 'KEYS_SIGN_REQUEST': {
			return {
				...state,
				signLoading: false,
				signRequest: action.payload,
		  }
		}
		case 'KEYS_SIGN_RESPONSE': {
			return {
				...state,
				signLoading: false,
				signRequest: null,
				sign: action.payload,
			}
		}
    
		case 'KEYS_SIGN_FILE_REQUEST': {
			return {
				...state,
				signFileLoading: false,
				signFileRequest: action.payload,
		  }
		}
		case 'KEYS_SIGN_FILE_RESPONSE': {
			return {
				...state,
				signFileLoading: false,
				signFileRequest: null,
				signFile: action.payload,
			}
		}
    
		case 'KEYS_SIGN_STREAM_REQUEST': {
			return {
				...state,
				signStreamLoading: false,
				signStreamRequest: action.payload,
		  }
		}
		case 'KEYS_SIGN_STREAM_RESPONSE': {
			return {
				...state,
				signStreamLoading: false,
				signStreamRequest: null,
				signStream: action.payload,
			}
		}
    
		case 'KEYS_VERIFY_REQUEST': {
			return {
				...state,
				verifyLoading: false,
				verifyRequest: action.payload,
		  }
		}
		case 'KEYS_VERIFY_RESPONSE': {
			return {
				...state,
				verifyLoading: false,
				verifyRequest: null,
				verify: action.payload,
			}
		}
    
		case 'KEYS_VERIFY_FILE_REQUEST': {
			return {
				...state,
				verifyFileLoading: false,
				verifyFileRequest: action.payload,
		  }
		}
		case 'KEYS_VERIFY_FILE_RESPONSE': {
			return {
				...state,
				verifyFileLoading: false,
				verifyFileRequest: null,
				verifyFile: action.payload,
			}
		}
    
		case 'KEYS_VERIFY_STREAM_REQUEST': {
			return {
				...state,
				verifyStreamLoading: false,
				verifyStreamRequest: action.payload,
		  }
		}
		case 'KEYS_VERIFY_STREAM_RESPONSE': {
			return {
				...state,
				verifyStreamLoading: false,
				verifyStreamRequest: null,
				verifyStream: action.payload,
			}
		}
    
		case 'KEYS_VERIFY_ARMORED_STREAM_REQUEST': {
			return {
				...state,
				verifyArmoredStreamLoading: false,
				verifyArmoredStreamRequest: action.payload,
		  }
		}
		case 'KEYS_VERIFY_ARMORED_STREAM_RESPONSE': {
			return {
				...state,
				verifyArmoredStreamLoading: false,
				verifyArmoredStreamRequest: null,
				verifyArmoredStream: action.payload,
			}
		}
    
		case 'KEYS_ENCRYPT_REQUEST': {
			return {
				...state,
				encryptLoading: false,
				encryptRequest: action.payload,
		  }
		}
		case 'KEYS_ENCRYPT_RESPONSE': {
			return {
				...state,
				encryptLoading: false,
				encryptRequest: null,
				encrypt: action.payload,
			}
		}
    
		case 'KEYS_ENCRYPT_STREAM_REQUEST': {
			return {
				...state,
				encryptStreamLoading: false,
				encryptStreamRequest: action.payload,
		  }
		}
		case 'KEYS_ENCRYPT_STREAM_RESPONSE': {
			return {
				...state,
				encryptStreamLoading: false,
				encryptStreamRequest: null,
				encryptStream: action.payload,
			}
		}
    
		case 'KEYS_ENCRYPT_FILE_REQUEST': {
			return {
				...state,
				encryptFileLoading: false,
				encryptFileRequest: action.payload,
		  }
		}
		case 'KEYS_ENCRYPT_FILE_RESPONSE': {
			return {
				...state,
				encryptFileLoading: false,
				encryptFileRequest: null,
				encryptFile: action.payload,
			}
		}
    
		case 'KEYS_DECRYPT_REQUEST': {
			return {
				...state,
				decryptLoading: false,
				decryptRequest: action.payload,
		  }
		}
		case 'KEYS_DECRYPT_RESPONSE': {
			return {
				...state,
				decryptLoading: false,
				decryptRequest: null,
				decrypt: action.payload,
			}
		}
    
		case 'KEYS_DECRYPT_FILE_REQUEST': {
			return {
				...state,
				decryptFileLoading: false,
				decryptFileRequest: action.payload,
		  }
		}
		case 'KEYS_DECRYPT_FILE_RESPONSE': {
			return {
				...state,
				decryptFileLoading: false,
				decryptFileRequest: null,
				decryptFile: action.payload,
			}
		}
    
		case 'KEYS_DECRYPT_STREAM_REQUEST': {
			return {
				...state,
				decryptStreamLoading: false,
				decryptStreamRequest: action.payload,
		  }
		}
		case 'KEYS_DECRYPT_STREAM_RESPONSE': {
			return {
				...state,
				decryptStreamLoading: false,
				decryptStreamRequest: null,
				decryptStream: action.payload,
			}
		}
    
		case 'KEYS_DECRYPT_ARMORED_STREAM_REQUEST': {
			return {
				...state,
				decryptArmoredStreamLoading: false,
				decryptArmoredStreamRequest: action.payload,
		  }
		}
		case 'KEYS_DECRYPT_ARMORED_STREAM_RESPONSE': {
			return {
				...state,
				decryptArmoredStreamLoading: false,
				decryptArmoredStreamRequest: null,
				decryptArmoredStream: action.payload,
			}
		}
    
		case 'KEYS_SIGNCRYPT_OPEN_STREAM_REQUEST': {
			return {
				...state,
				signcryptOpenStreamLoading: false,
				signcryptOpenStreamRequest: action.payload,
		  }
		}
		case 'KEYS_SIGNCRYPT_OPEN_STREAM_RESPONSE': {
			return {
				...state,
				signcryptOpenStreamLoading: false,
				signcryptOpenStreamRequest: null,
				signcryptOpenStream: action.payload,
			}
		}
    
		case 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM_REQUEST': {
			return {
				...state,
				signcryptOpenArmoredStreamLoading: false,
				signcryptOpenArmoredStreamRequest: action.payload,
		  }
		}
		case 'KEYS_SIGNCRYPT_OPEN_ARMORED_STREAM_RESPONSE': {
			return {
				...state,
				signcryptOpenArmoredStreamLoading: false,
				signcryptOpenArmoredStreamRequest: null,
				signcryptOpenArmoredStream: action.payload,
			}
		}
    
		case 'KEYS_SIGCHAIN_REQUEST': {
			return {
				...state,
				sigchainLoading: false,
				sigchainRequest: action.payload,
		  }
		}
		case 'KEYS_SIGCHAIN_RESPONSE': {
			return {
				...state,
				sigchainLoading: false,
				sigchainRequest: null,
				sigchain: action.payload,
			}
		}
    
		case 'KEYS_STATEMENT_REQUEST': {
			return {
				...state,
				statementLoading: false,
				statementRequest: action.payload,
		  }
		}
		case 'KEYS_STATEMENT_RESPONSE': {
			return {
				...state,
				statementLoading: false,
				statementRequest: null,
				statement: action.payload,
			}
		}
    
		case 'KEYS_STATEMENT_CREATE_REQUEST': {
			return {
				...state,
				statementCreateLoading: false,
				statementCreateRequest: action.payload,
		  }
		}
		case 'KEYS_STATEMENT_CREATE_RESPONSE': {
			return {
				...state,
				statementCreateLoading: false,
				statementCreateRequest: null,
				statementCreate: action.payload,
			}
		}
    
		case 'KEYS_STATEMENT_REVOKE_REQUEST': {
			return {
				...state,
				statementRevokeLoading: false,
				statementRevokeRequest: action.payload,
		  }
		}
		case 'KEYS_STATEMENT_REVOKE_RESPONSE': {
			return {
				...state,
				statementRevokeLoading: false,
				statementRevokeRequest: null,
				statementRevoke: action.payload,
			}
		}
    
		case 'KEYS_USER_SEARCH_REQUEST': {
			return {
				...state,
				userSearchLoading: false,
				userSearchRequest: action.payload,
		  }
		}
		case 'KEYS_USER_SEARCH_RESPONSE': {
			return {
				...state,
				userSearchLoading: false,
				userSearchRequest: null,
				userSearch: action.payload,
			}
		}
    
		case 'KEYS_USER_SERVICE_REQUEST': {
			return {
				...state,
				userServiceLoading: false,
				userServiceRequest: action.payload,
		  }
		}
		case 'KEYS_USER_SERVICE_RESPONSE': {
			return {
				...state,
				userServiceLoading: false,
				userServiceRequest: null,
				userService: action.payload,
			}
		}
    
		case 'KEYS_USER_SIGN_REQUEST': {
			return {
				...state,
				userSignLoading: false,
				userSignRequest: action.payload,
		  }
		}
		case 'KEYS_USER_SIGN_RESPONSE': {
			return {
				...state,
				userSignLoading: false,
				userSignRequest: null,
				userSign: action.payload,
			}
		}
    
		case 'KEYS_USER_ADD_REQUEST': {
			return {
				...state,
				userAddLoading: false,
				userAddRequest: action.payload,
		  }
		}
		case 'KEYS_USER_ADD_RESPONSE': {
			return {
				...state,
				userAddLoading: false,
				userAddRequest: null,
				userAdd: action.payload,
			}
		}
    
		case 'KEYS_ITEM_REQUEST': {
			return {
				...state,
				itemLoading: false,
				itemRequest: action.payload,
		  }
		}
		case 'KEYS_ITEM_RESPONSE': {
			return {
				...state,
				itemLoading: false,
				itemRequest: null,
				item: action.payload,
			}
		}
    
		case 'KEYS_ITEMS_REQUEST': {
			return {
				...state,
				itemsLoading: false,
				itemsRequest: action.payload,
		  }
		}
		case 'KEYS_ITEMS_RESPONSE': {
			return {
				...state,
				itemsLoading: false,
				itemsRequest: null,
				items: action.payload,
			}
		}
    
		case 'KEYS_PULL_REQUEST': {
			return {
				...state,
				pullLoading: false,
				pullRequest: action.payload,
		  }
		}
		case 'KEYS_PULL_RESPONSE': {
			return {
				...state,
				pullLoading: false,
				pullRequest: null,
				pull: action.payload,
			}
		}
    
		case 'KEYS_PUSH_REQUEST': {
			return {
				...state,
				pushLoading: false,
				pushRequest: action.payload,
		  }
		}
		case 'KEYS_PUSH_RESPONSE': {
			return {
				...state,
				pushLoading: false,
				pushRequest: null,
				push: action.payload,
			}
		}
    
		case 'KEYS_CONFIG_REQUEST': {
			return {
				...state,
				configLoading: false,
				configRequest: action.payload,
		  }
		}
		case 'KEYS_CONFIG_RESPONSE': {
			return {
				...state,
				configLoading: false,
				configRequest: null,
				config: action.payload,
			}
		}
    
		case 'KEYS_CONFIG_SET_REQUEST': {
			return {
				...state,
				configSetLoading: false,
				configSetRequest: action.payload,
		  }
		}
		case 'KEYS_CONFIG_SET_RESPONSE': {
			return {
				...state,
				configSetLoading: false,
				configSetRequest: null,
				configSet: action.payload,
			}
		}
    
		case 'KEYS_APP_STATUS_REQUEST': {
			return {
				...state,
				appStatusLoading: false,
				appStatusRequest: action.payload,
		  }
		}
		case 'KEYS_APP_STATUS_RESPONSE': {
			return {
				...state,
				appStatusLoading: false,
				appStatusRequest: null,
				appStatus: action.payload,
			}
		}
    
		case 'KEYS_AUTH_SETUP_REQUEST': {
			return {
				...state,
				authSetupLoading: false,
				authSetupRequest: action.payload,
		  }
		}
		case 'KEYS_AUTH_SETUP_RESPONSE': {
			return {
				...state,
				authSetupLoading: false,
				authSetupRequest: null,
				authSetup: action.payload,
			}
		}
    
		case 'KEYS_AUTH_UNLOCK_REQUEST': {
			return {
				...state,
				authUnlockLoading: false,
				authUnlockRequest: action.payload,
		  }
		}
		case 'KEYS_AUTH_UNLOCK_RESPONSE': {
			return {
				...state,
				authUnlockLoading: false,
				authUnlockRequest: null,
				authUnlock: action.payload,
			}
		}
    
		case 'KEYS_AUTH_LOCK_REQUEST': {
			return {
				...state,
				authLockLoading: false,
				authLockRequest: action.payload,
		  }
		}
		case 'KEYS_AUTH_LOCK_RESPONSE': {
			return {
				...state,
				authLockLoading: false,
				authLockRequest: null,
				authLock: action.payload,
			}
		}
    
		case 'KEYS_RUNTIME_STATUS_REQUEST': {
			return {
				...state,
				runtimeStatusLoading: false,
				runtimeStatusRequest: action.payload,
		  }
		}
		case 'KEYS_RUNTIME_STATUS_RESPONSE': {
			return {
				...state,
				runtimeStatusLoading: false,
				runtimeStatusRequest: null,
				runtimeStatus: action.payload,
			}
		}
    
		case 'KEYS_RAND_REQUEST': {
			return {
				...state,
				randLoading: false,
				randRequest: action.payload,
		  }
		}
		case 'KEYS_RAND_RESPONSE': {
			return {
				...state,
				randLoading: false,
				randRequest: null,
				rand: action.payload,
			}
		}
    
		case 'KEYS_COLLECTIONS_REQUEST': {
			return {
				...state,
				collectionsLoading: false,
				collectionsRequest: action.payload,
		  }
		}
		case 'KEYS_COLLECTIONS_RESPONSE': {
			return {
				...state,
				collectionsLoading: false,
				collectionsRequest: null,
				collections: action.payload,
			}
		}
    
		case 'KEYS_DOCUMENTS_REQUEST': {
			return {
				...state,
				documentsLoading: false,
				documentsRequest: action.payload,
		  }
		}
		case 'KEYS_DOCUMENTS_RESPONSE': {
			return {
				...state,
				documentsLoading: false,
				documentsRequest: null,
				documents: action.payload,
			}
		}
    
		case 'KEYS_DOCUMENT_DELETE_REQUEST': {
			return {
				...state,
				documentDeleteLoading: false,
				documentDeleteRequest: action.payload,
		  }
		}
		case 'KEYS_DOCUMENT_DELETE_RESPONSE': {
			return {
				...state,
				documentDeleteLoading: false,
				documentDeleteRequest: null,
				documentDelete: action.payload,
			}
		}
    
		case 'KEYS_INBOX_REQUEST': {
			return {
				...state,
				inboxLoading: false,
				inboxRequest: action.payload,
		  }
		}
		case 'KEYS_INBOX_RESPONSE': {
			return {
				...state,
				inboxLoading: false,
				inboxRequest: null,
				inbox: action.payload,
			}
		}
    
		case 'KEYS_MESSAGE_PREPARE_REQUEST': {
			return {
				...state,
				messagePrepareLoading: false,
				messagePrepareRequest: action.payload,
		  }
		}
		case 'KEYS_MESSAGE_PREPARE_RESPONSE': {
			return {
				...state,
				messagePrepareLoading: false,
				messagePrepareRequest: null,
				messagePrepare: action.payload,
			}
		}
    
		case 'KEYS_MESSAGE_CREATE_REQUEST': {
			return {
				...state,
				messageCreateLoading: false,
				messageCreateRequest: action.payload,
		  }
		}
		case 'KEYS_MESSAGE_CREATE_RESPONSE': {
			return {
				...state,
				messageCreateLoading: false,
				messageCreateRequest: null,
				messageCreate: action.payload,
			}
		}
    
		case 'KEYS_MESSAGES_REQUEST': {
			return {
				...state,
				messagesLoading: false,
				messagesRequest: action.payload,
		  }
		}
		case 'KEYS_MESSAGES_RESPONSE': {
			return {
				...state,
				messagesLoading: false,
				messagesRequest: null,
				messages: action.payload,
			}
		}
    
		case 'KEYS_WATCH_REQUEST': {
			return {
				...state,
				watchLoading: false,
				watchRequest: action.payload,
		  }
		}
		case 'KEYS_WATCH_RESPONSE': {
			return {
				...state,
				watchLoading: false,
				watchRequest: null,
				watch: action.payload,
			}
		}
    default:
      return state
  }
}

export type ErrFn = (err: RPCError) => void
export type ErrHandler = (err: RPCError, errFn: ErrFn | void) => void
var errHandler: ErrHandler | void = null
export const setErrHandler = (eh: ErrHandler | void) => {
  errHandler = eh
}
	

